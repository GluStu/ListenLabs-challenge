import requests

BASE_URL = "https://berghain.challenges.listenlabs.ai"
PLAYER_ID = "" #Your player ID
SCENARIO = 2
person_index = 0

print("Starting new game...")
try:
    res = requests.get(f"{BASE_URL}/new-game?scenario={SCENARIO}&playerId={PLAYER_ID}")
    res.raise_for_status()
    game = res.json()
except Exception as e:
    print("Failed to start game:", e)
    exit(1)

game_id = game["gameId"]
constraints = game["constraints"]

print(f"Game ID: {game_id}")

try:
    url = f"{BASE_URL}/decide-and-next?gameId={game_id}&personIndex=0"
    res = requests.get(url)
    res.raise_for_status()
    data = res.json()
    current_person = data["nextPerson"]
except Exception as e:
    print("Failed to get first person:", e)
    exit(1)

# attributes in order: T, W, C, B
MIN_REQ = {"T": 650, "W": 450, "C": 300, "B": 750}
K = 1000

accepted = 0
acc_attr = {"T": 0, "W": 0, "C": 0, "B": 0}

def decide(candidate):  # candidate is a dict {"T":0/1, "W":0/1, "C":0/1, "B":0/1}
    # global accepted, acc_attr

    # S = K - accepted
    # r = {j: max(0, MIN_REQ[j] - acc_attr[j]) for j in MIN_REQ}

    # # 1) hard locks
    # locked = [j for j in r if r[j] == S]
    # if locked and not all(candidate[j] == 1 for j in locked):
    #     return True

    # # 2) mandatory pair guardrail
    # attrs = ["T","W","C","B"]
    # for i in range(len(attrs)):
    #     for j in range(i+1,len(attrs)):
    #         ni = attrs[i]; nj = attrs[j]
    #         need_pair = max(0, r[ni] + r[nj] - S)
    #         if need_pair > 0 and candidate[ni] == 0 and candidate[nj] == 0:
    #             return False

    # # 3) greedy accept
    # accepted += 1
    # for j in MIN_REQ:
    #     if candidate[j] == 1:
    #         acc_attr[j] += 1
    # return True

    global accepted, acc_attr

    S = K - accepted
    r = {j: max(0, MIN_REQ[j] - acc_attr[j]) for j in MIN_REQ}

    # 1) hard locks: if any attribute needs exactly S more, it is mandatory
    locked = [j for j in r if r[j] == S and r[j] > 0]
    if locked and not all(candidate.get(j, 0) == 1 for j in locked):
        return False  # <-- reject if a hard-locked attribute is missing

    # 1b) single-unmet rule: if exactly one attribute is still unmet, require it
    unmet = [j for j, need in r.items() if need > 0]
    if len(unmet) == 1 and candidate.get(unmet[0], 0) == 0:
        return False

    # 2) mandatory pair guardrail
    attrs = ["T", "W", "C", "B"]
    for i in range(len(attrs)):
        for j in range(i + 1, len(attrs)):
            ni = attrs[i]; nj = attrs[j]
            need_pair = max(0, r[ni] + r[nj] - S)
            if need_pair > 0 and candidate.get(ni, 0) == 0 and candidate.get(nj, 0) == 0:
                return False

    # 3) greedy accept
    accepted += 1
    for j in MIN_REQ:
        if candidate.get(j, 0) == 1:
            acc_attr[j] += 1
    return True

while True:
    try:
        attrs = current_person["attributes"]
        techno_lover = attrs.get("techno_lover", False)
        well_connected = attrs.get("well_connected", False)
        creative = attrs.get("creative", False)
        berlin_local = attrs.get("berlin_local", False)
        accept = decide({"T": techno_lover,"W": well_connected,"C": creative,"B": berlin_local})
        if acc_attr["B"] >= 750 and acc_attr["W"] >= 450 and acc_attr["C"] >= 300 and acc_attr["T"] >= 650:
            accept = True
        decision = "accept" if accept else "reject"

        print(f"[{current_person['personIndex']}] techno_lover: {techno_lover}, well_connected: {well_connected}, creative: {creative}, berlin: {berlin_local} => {decision}")

        url = f"{BASE_URL}/decide-and-next?gameId={game_id}&personIndex={person_index}&accept={str(accept).lower()}"
        res = requests.get(url)
        res.raise_for_status()
        data = res.json()

        current_person = data["nextPerson"]
        person_index += 1

    except requests.exceptions.RequestException as e:
        print("HTTP request failed:", e)
        break
    except Exception as e:
        print("Unexpected error:", e)
        break
